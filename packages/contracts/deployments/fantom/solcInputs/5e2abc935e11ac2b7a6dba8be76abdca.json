{
  "language": "Solidity",
  "sources": {
    "contracts/CommunityOffering/CommunityOffering.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.5;\n\nimport \"./CommunityOfferingNRT.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// *********************************\n// Fair Launch pool\n// *********************************\n// cap increases gradually over time\n// this allows a maximum number of participants and still fill the round\n\ncontract CommunityOffering is Ownable {\n    \n    // the token address the cash is raised in\n    // assume decimals is 18\n    address public investToken;\n    // the token to be launched\n    address public launchToken;\n    // proceeds go to treasury\n    address public treasury;\n    // the certificate\n    CommunityOfferingNRT public nrt;\n    // fixed single price\n    uint256 public price = 8;\n    // ratio quote in 100\n    uint256 public priceQuote = 100;\n    // the cap at the beginning\n    uint256 public initialCap;\n    // maximum cap\n    uint256 public maxCap;\n    // the total amount in stables to be raised\n    uint256 public totalraiseCap;\n    // how much was raised\n    uint256 public totalraised;\n    // how much was issued\n    uint256 public totalissued;\n    // how much was redeemed\n    uint256 public totalredeem;\n    // start of the sale\n    uint256 public startTime;\n    // total duration\n    uint256 public duration;\n    // length of each epoch\n    uint256 public epochTime;\n    // end of the sale    \n    uint256 public endTime;\n    // sale has started\n    bool public saleEnabled;\n    // redeem is possible\n    bool public redeemEnabled;\n    // minimum amount\n    uint256 public mininvest;\n    //MAG decimals = 9, MIM decimals = 18\n    uint256 public launchDecimals = 9; \n    //\n    uint256 public numWhitelisted = 0;\n    //\n    uint256 public numInvested = 0;\n    \n    event SaleEnabled(bool enabled, uint256 time);\n    event RedeemEnabled(bool enabled, uint256 time);\n    event Invest(address investor, uint256 amount);\n    event Redeem(address investor, uint256 amount);\n\n    struct InvestorInfo {\n        uint256 amountInvested; // Amount deposited by user\n        bool claimed; // has claimed MAG\n    }\n\n    // user is whitelisted\n    mapping(address => bool) public whitelisted;\n\n    mapping(address => InvestorInfo) public investorInfoMap;\n    \n    constructor(\n        address _investToken,\n        uint256 _startTime,  \n        uint256 _duration,  \n        uint256 _epochTime,\n        uint256 _initialCap,     \n        uint256 _totalraiseCap,\n        uint256 _minInvest,\n        address _treasury,\n        address _nrtAddress\n    ) {\n        investToken = _investToken;\n        startTime = _startTime;\n        duration = _duration;\n        epochTime = _epochTime;\n        initialCap = _initialCap;        \n        totalraiseCap = _totalraiseCap;\n        mininvest = _minInvest; \n        treasury = _treasury;\n        require(duration < 7 days, \"duration too long\");\n        endTime = startTime + duration;\n        nrt = CommunityOfferingNRT(_nrtAddress);\n        redeemEnabled = false;\n        saleEnabled = false;\n        maxCap = 800 * 10 ** 18; // Per Person maximum contribution is 800 USDC\n    }\n\n    // adds an address to the whitelist\n    function addWhitelist(address _address) external onlyOwner {        \n        //require(!whitelisted[_address], \"already whitelisted\");\n        whitelisted[_address] = true;\n        numWhitelisted+=1; \n    }\n\n    // adds multiple addresses\n    function addMultipleWhitelist(address[] calldata _addresses) external onlyOwner {        \n        require(_addresses.length <= 1000, \"too many addresses\");\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            whitelisted[_addresses[i]] = true;  \n            numWhitelisted+=1;          \n        }\n    }\n\n    // removes a single address from the sale\n    function removeWhitelist(address _address) external onlyOwner {        \n        whitelisted[_address] = false;\n    }\n\n    function currentEpoch() public view returns (uint256){     \n        if(block.timestamp < startTime)\n            return 0;    \n        else       \n            return (block.timestamp - startTime)/epochTime;\n    }\n\n    // the current cap. increases exponentially\n    function currentCap() public view returns (uint256){   \n        uint256 epochs = currentEpoch();\n        uint256 cap = initialCap * (2 ** epochs);\n        if (cap > maxCap){\n            return maxCap;\n        } else {\n            return cap;\n        }\n    }\n    \n    // invest up to current cap\n    function invest(uint256 investAmount) public {\n        require(block.timestamp >= startTime, \"not started yet\");\n        require(saleEnabled, \"not enabled yet\");\n        require(whitelisted[msg.sender] == true, 'msg.sender is not whitelisted');\n        require(totalraised + investAmount <= totalraiseCap, \"over total raise\");\n        require(investAmount >= mininvest, \"below minimum invest\");\n        require(block.timestamp <= endTime, \"sales ended\");\n\n        uint256 xcap = currentCap();\n\n        InvestorInfo storage investor = investorInfoMap[msg.sender];\n\n        require(investor.amountInvested + investAmount <= xcap, \"above cap\");        \n\n        require(\n            IERC20(investToken).transferFrom(\n                msg.sender,\n                address(this),\n                investAmount\n            ),\n            \"transfer failed\"\n        );\n\n        //Frock decimals = 9, USDC decimals = 6\n        uint256 issueAmount = investAmount * 10**launchDecimals * priceQuote / price / 10**6 ;                \n\n\n        nrt.issue(msg.sender, issueAmount);\n\n        totalraised += investAmount;\n        totalissued += issueAmount;\n        if (investor.amountInvested == 0){\n            numInvested += 1;\n        }\n        investor.amountInvested += investAmount;\n        \n        emit Invest(msg.sender, investAmount);\n    }\n\n    // redeem all tokens\n    function redeem() public {        \n        require(redeemEnabled, \"redeem not enabled\");\n        require(block.timestamp > endTime, \"not redeemable yet\");\n        uint256 redeemAmount = nrt.balanceOf(msg.sender);\n        require(redeemAmount > 0, \"no amount issued\");\n        InvestorInfo storage investor = investorInfoMap[msg.sender];\n        require(!investor.claimed, \"already claimed\");\n        require(\n            IERC20(launchToken).transfer(\n                msg.sender,\n                redeemAmount\n            ),\n            \"transfer failed\"\n        );\n\n        nrt.redeem(msg.sender, redeemAmount);\n\n        totalredeem += redeemAmount;        \n        emit Redeem(msg.sender, redeemAmount);\n        investor.claimed = true;\n    }\n\n    // -- admin functions --\n\n    // define the launch token to be redeemed\n    function setLaunchToken(address _launchToken) public onlyOwner {\n        launchToken = _launchToken;\n    }\n\n    function depositLaunchtoken(uint256 amount) public onlyOwner {\n        require(\n            IERC20(launchToken).transferFrom(msg.sender, address(this), amount),\n            \"transfer failed\"\n        );\n    }\n\n    // withdraw in case some tokens were not redeemed\n    function withdrawLaunchtoken(uint256 amount) public onlyOwner {\n        require(\n            IERC20(launchToken).transfer(msg.sender, amount),\n            \"transfer failed\"\n        );\n    }\n\n    // withdraw funds to treasury\n    function withdrawTreasury(uint256 amount) public onlyOwner {\n        //uint256 b = IERC20(investToken).balanceOf(address(this));\n        require(\n            IERC20(investToken).transfer(treasury, amount),\n            \"transfer failed\"\n        );\n    }\n\n    function enableSale() public onlyOwner {\n        saleEnabled = true;\n        emit SaleEnabled(true, block.timestamp);\n    }\n\n    function enableRedeem() public onlyOwner { \n        require(launchToken != address(0), \"launch token not set\");\n        redeemEnabled = true;\n        emit RedeemEnabled(true, block.timestamp);\n    }\n}"
    },
    "contracts/CommunityOffering/CommunityOfferingNRT.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.5;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n//NRT is like a private stock\n//can only be traded with the issuer who remains in control of the market\n//until he opens the redemption window\ncontract CommunityOfferingNRT is Ownable {\n    uint256 private _issuedSupply;\n    uint256 private _outstandingSupply;\n    uint256 private _decimals;\n    string private _symbol;\n\n    mapping(address => uint256) private _balances;\n\n    event Issued(address account, uint256 amount);\n    event Redeemed(address account, uint256 amount);\n\n    constructor(string memory __symbol, uint256 __decimals) {\n        _symbol = __symbol;\n        _decimals = __decimals;\n        _issuedSupply = 0;\n        _outstandingSupply = 0;\n    }\n\n    // Creates amount NRT and assigns them to account\n    function issue(address account, uint256 amount) public onlyOwner {\n        require(account != address(0), \"zero address\");\n\n        _issuedSupply += amount;\n        _outstandingSupply += amount;\n        _balances[account] += amount;\n\n        emit Issued(account, amount);\n    }\n\n    //redeem, caller handles transfer of created value\n    function redeem(address account, uint256 amount) public onlyOwner {\n        require(account != address(0), \"zero address\");\n        require(_balances[account] >= amount, \"Insufficent balance\");\n\n        _balances[account] -= amount;\n        _outstandingSupply -= amount;\n\n        emit Redeemed(account, amount);\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint256) {\n        return _decimals;\n    }\n\n    function issuedSupply() public view returns (uint256) {\n        return _issuedSupply;\n    }\n\n    function outstandingSupply() public view returns (uint256) {\n        return _outstandingSupply;\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/FairLaunch/FairPriceLaunch.sol": {
      "content": "// https://eips.ethereum.org/EIPS/eip-20\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.5;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./FairLaunchNRT.sol\";\n\n////////////////////////////////////\n//\n//  Fair Price Launch Contract\n//  Every gets the same price in the end\n//  Users get issued a non-transferable token  and redeem for the final token\n//\n////////////////////////////////////\ncontract FairPriceLaunch is Ownable {   \n    using SafeMath for uint256; \n\n    FairLaunchNRT public nrt;\n\n    address public fundsRedeemer;\n    // The token used for contributions\n    address public investToken;\n\n    // the token to be launched\n    address public launchToken;\n    \n\n    //Limits\n    uint256 public maxInvestAllowed;\n    uint256 public minInvestAllowed;\n    uint256 public maxInvestRemovablePerPeriod;\n    uint256 public maxGlobalInvestAllowed;\n    uint256 public maxRedeemableToIssue;\n\n    //totals\n    uint256 public totalGlobalInvested;\n    uint256 public totalGlobalIssued;\n    uint256 public totalGlobalRedeemed;\n    uint256 public totalInvestors;\n\n    //TIMES\n    // The time that sale will begin\n    uint256 public launchStartTime;\n    // length of sale period\n    uint256 public saleDuration;\n    // launchStartTime.add(sale) durations\n    uint256 public launchEndTime;\n    //The delay required between investment removal\n    uint256 public investRemovalDelay;\n    //Prices\n    uint256 public startingPrice;\n    uint256 public finalPrice;\n\n    //toggles\n    // sale has started\n    bool public saleEnabled;\n    bool public claimEnabled;\n    bool public redeemEnabled;\n    bool public finalized;\n\n    //EVENTS\n    event SaleEnabled(bool enabled, uint256 time);\n    event ClaimEnabled(bool enabled, uint256 time);\n    event RedeemEnabled(bool enabled, uint256 time);\n\n    event Invest(\n        address investor,\n        uint256 amount,\n        uint256 totalInvested,\n        uint256 price\n    );\n    event RemoveInvestment(\n        address investor,\n        uint256 amount,\n        uint256 totalInvested,\n        uint256 price\n    );\n    event Claimed(address account, uint256 amount);\n    event Redeemed(address account, uint256 amount);\n\n    //Structs\n\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n\n    struct InvestorInfo {\n        uint256 totalInvested;\n        uint256 totalClaimed;\n        uint256 totalRedeemed;\n        uint256 totalInvestableExchanged;\n        Withdrawal[] withdrawHistory;\n        bool hasClaimed;\n        bool hasRedeemed;\n    }\n\n    mapping(address => InvestorInfo) public investorInfoMap;\n    address[] public investorList;\n\n    constructor(\n        address _fundsRedeemer,\n        address _investToken,\n        address _nrtAddress,\n        uint256 _launchStartTime,\n        uint256 _saleDuration,\n        uint256 _investRemovalDelay,\n        uint256 _maxInvestAllowed,\n        uint256 _minInvestAllowed,\n        uint256 _maxInvestRemovablePerPeriod,\n        uint256 _maxGlobalInvestAllowed,\n        uint256 _maxRedeemableToIssue,\n        uint256 _startingPrice        \n    ) {\n        require(\n            _launchStartTime > block.timestamp,\n            \"Start time must be in the future.\"\n        );\n        require(\n            _minInvestAllowed >= 0,\n            \"Min invest amount must not be negative\"\n        );\n        require(_startingPrice >= 0, \"Starting price must not be negative\");\n        require(_fundsRedeemer != address(0), \"fundsRedeemer address is not set.\");\n\n        fundsRedeemer = _fundsRedeemer;\n        investToken = _investToken;\n        //times\n        launchStartTime = _launchStartTime;\n        require(_saleDuration < 4 days, \"duration too long\");\n        launchEndTime = _launchStartTime.add(_saleDuration);\n        saleDuration = _saleDuration;\n        investRemovalDelay = _investRemovalDelay;\n        //limits\n        maxInvestAllowed = _maxInvestAllowed;\n        minInvestAllowed = _minInvestAllowed;\n        maxGlobalInvestAllowed = _maxGlobalInvestAllowed;\n        maxInvestRemovablePerPeriod = _maxInvestRemovablePerPeriod;\n        maxRedeemableToIssue = _maxRedeemableToIssue;\n        startingPrice = _startingPrice;\n        //NRT is passed in as argument and this contract needs to be set as owner        \n        saleEnabled = false;\n        claimEnabled = false;\n        redeemEnabled = false;\n\n        // NRT\n        nrt = FairLaunchNRT(_nrtAddress);\n    }\n\n    //User functions\n    /**\n    @dev Invests the specified amoount of investToken\n     */\n    function invest(uint256 amountToInvest) public {\n        require(saleEnabled, \"Sale is not enabled yet\");\n        require(block.timestamp >= launchStartTime, \"Sale has not started yet\");\n        require(amountToInvest >= minInvestAllowed, \"Invest amount too small\");\n        require(!hasSaleEnded(), \"Sale period has ended\");        \n        require(\n            totalGlobalInvested.add(amountToInvest) <= maxGlobalInvestAllowed,\n            \"Maximum Investments reached\"\n        );\n\n        InvestorInfo storage investor = investorInfoMap[msg.sender];\n        require(\n            investor.totalInvested.add(amountToInvest) <= maxInvestAllowed,\n            \"Max individual investment reached\"\n        );\n        //transact\n        require(\n            IERC20(investToken).transferFrom(\n                msg.sender,\n                address(this),\n                amountToInvest\n            ),\n            \"transfer failed\"\n        );\n        if (investor.totalInvested == 0) {\n            totalInvestors += 1;\n            investorList.push(msg.sender);\n        }\n        investor.totalInvestableExchanged += amountToInvest;\n        investor.totalInvested += amountToInvest;\n        totalGlobalInvested += amountToInvest;\n        //continuously updates finalPrice until the last contribution is made.\n        finalPrice = currentPrice();\n        emit Invest(\n            msg.sender,\n            amountToInvest,\n            totalGlobalInvested,\n            finalPrice\n        );\n    }\n\n    /**\n    @dev Returns the total amount withdrawn by the _address during the last hour\n    **/\n\n    function getLastPeriodWithdrawals(address _address)\n        public\n        view\n        returns (uint256 totalWithdrawLastHour)\n    {\n        InvestorInfo storage investor = investorInfoMap[_address];\n\n        Withdrawal[] storage withdrawHistory = investor.withdrawHistory;\n        for (uint256 i = 0; i < withdrawHistory.length; i++) {\n            Withdrawal memory withdraw = withdrawHistory[i];\n            if (withdraw.timestamp >= block.timestamp.sub(investRemovalDelay)) {\n                totalWithdrawLastHour = totalWithdrawLastHour.add(\n                    withdrawHistory[i].amount\n                );\n            }\n        }\n    }\n\n    /**\n    @dev Removes the specified amount from the users totalInvested balance and returns the amount of investTokens back to them\n     */\n    function removeInvestment(uint256 amountToRemove) public {\n        require(saleEnabled, \"Sale is not enabled yet\");\n        require(block.timestamp >= launchStartTime, \"Sale has not started yet\");\n        require(block.timestamp < launchEndTime, \"Sale has ended\");\n        require(\n            totalGlobalInvested < maxGlobalInvestAllowed,\n            \"Maximum Investments reached, deposits/withdrawal are disabled\"\n        );\n        require(amountToRemove <= maxInvestRemovablePerPeriod, \"Cannot remove more than the maximum by period\");\n\n        InvestorInfo storage investor = investorInfoMap[msg.sender];\n\n        //Two checks of funds to prevent over widrawal\n        require(\n            amountToRemove <= investor.totalInvested,\n            \"Cannot Remove more than invested\"\n        );\n        \n        //Make sure they can't withdraw too often.\n        Withdrawal[] storage withdrawHistory = investor.withdrawHistory;\n        uint256 authorizedWithdraw = maxInvestRemovablePerPeriod.sub(\n            getLastPeriodWithdrawals(msg.sender)\n        );\n        require(\n            amountToRemove <= authorizedWithdraw,\n            \"Max withdraw reached for this hour\"\n        );\n        withdrawHistory.push(\n            Withdrawal({timestamp: block.timestamp, amount: amountToRemove})\n        );\n        //transact\n        investor.totalInvestableExchanged += amountToRemove;\n        investor.totalInvested -= amountToRemove;\n        totalGlobalInvested -= amountToRemove;\n        require(\n            IERC20(investToken).transferFrom(\n                address(this),\n                msg.sender,\n                amountToRemove\n            ),\n            \"transfer failed\"\n        );\n\n        finalPrice = currentPrice();\n\n        emit RemoveInvestment(\n            msg.sender,\n            amountToRemove,\n            totalGlobalInvested,\n            finalPrice\n        );\n    }\n\n    /**\n    * @dev Claims the NRT tokens equivalent to their contribution\n    */\n    function claimRedeemable() public {\n        require(claimEnabled, \"claim not enabled\");\n        require(block.timestamp >= launchEndTime, \"Time to claim has not arrived\");        \n\n        InvestorInfo storage investor = investorInfoMap[msg.sender];\n        require(!investor.hasClaimed, \"Tokens already claimed\");\n        require(investor.totalInvested > 0, \"No investment made\");        \n\n        uint256 issueAmount = investor.totalInvested.mul(10**9).div(finalPrice);\n        investor.hasClaimed = true;\n        investor.totalClaimed = issueAmount;\n        totalGlobalIssued = totalGlobalIssued.add(issueAmount);\n        \n        // Claim bFrock\n        require(issueAmount > 0, \"no amount issued\");\n        nrt.issue(msg.sender, issueAmount);\n      \n        emit Claimed(msg.sender, issueAmount);\n    }   \n\n\n    /**\n    * @dev redeem all tokens\n    */\n    function redeem() public {        \n        require(redeemEnabled, \"redeem not enabled\");\n        require(block.timestamp > launchEndTime, \"not redeemable yet\");\n        uint256 redeemAmount = nrt.balanceOf(msg.sender);\n        require(redeemAmount > 0, \"no amount issued\");\n        InvestorInfo storage investor = investorInfoMap[msg.sender];\n        require(!investor.hasRedeemed, \"already redeemed\");\n        require(launchToken != address(0), \"Launth token not setted\");\n\n        // Set ad Redeemed\n        investor.hasRedeemed = true;\n\n        // Send Frock Token to Investor\n        require(\n            IERC20(launchToken).transfer(\n                msg.sender,\n                redeemAmount\n            ),\n            \"transfer failed\"\n        );\n\n        // Redeem NRT and burn the NRT\n        nrt.redeem(msg.sender, redeemAmount);\n        \n        // Add Flobal Redeemed amount\n        totalGlobalRedeemed += redeemAmount;        \n        \n        emit Redeemed(msg.sender, redeemAmount);        \n    } \n\n    //getters\n    //calculates current price\n    function currentPrice() public view returns (uint256) {\n        uint256 price = computePrice();\n        if (price <= startingPrice) {\n            return startingPrice;\n        } else {\n            return price;\n        }\n    }\n\n    function computePrice() public view returns (uint256) {\n        return totalGlobalInvested.mul(1e9).div(maxRedeemableToIssue);\n    }\n\n    function hasSaleEnded() public view returns (bool) {\n        return block.timestamp > launchStartTime.add(saleDuration);\n    }\n\n    //------ Owner Functions ------\n\n     // define the launch token to be redeemed\n    function setLaunchToken(address _launchToken) public onlyOwner {\n        launchToken = _launchToken;\n    }\n\n    function enableSale() public onlyOwner {\n        saleEnabled = true;\n        emit SaleEnabled(true, block.timestamp);\n    }\n\n    function enableClaim() public onlyOwner {\n        claimEnabled = true;\n        emit ClaimEnabled(true, block.timestamp);\n    }\n\n    function enableRedeem() public onlyOwner {\n        redeemEnabled = true;\n        emit RedeemEnabled(true, block.timestamp);\n    }\n\n    function withdrawInvestablePool() public onlyOwner {\n        require(block.timestamp > launchEndTime, \"Sale has not ended\");\n        uint256 amount = IERC20(investToken).balanceOf(address(this));\n        IERC20(investToken).transfer(fundsRedeemer, amount);        \n    }\n\n     // withdraw in case some tokens were not redeemed\n    function withdrawLaunchtoken(uint256 amount) public onlyOwner {\n        require(\n            IERC20(launchToken).transfer(msg.sender, amount),\n            \"transfer failed\"\n        );\n    }\n\n    function changeStartTime(uint256 newTime) public onlyOwner {\n        require(newTime > block.timestamp, \"Start time must be in the future.\");\n        require(block.timestamp < launchStartTime, \"Sale has already started\");\n        launchStartTime = newTime;\n        //update endTime\n        launchEndTime = newTime.add(saleDuration);\n    }\n}"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/FairLaunch/FairLaunchNRT.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.5;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n//NRT is like a private stock\n//can only be traded with the issuer who remains in control of the market\n//until he opens the redemption window\ncontract FairLaunchNRT is Ownable {\n    uint256 private _issuedSupply;\n    uint256 private _outstandingSupply;\n    uint256 private _decimals;\n    string private _symbol;\n\n    mapping(address => uint256) private _balances;\n\n    event Issued(address account, uint256 amount);\n    event Redeemed(address account, uint256 amount);\n\n    constructor(string memory __symbol, uint256 __decimals) {\n        _symbol = __symbol;\n        _decimals = __decimals;\n        _issuedSupply = 0;\n        _outstandingSupply = 0;\n    }\n\n    // Creates amount NRT and assigns them to account\n    function issue(address account, uint256 amount) public onlyOwner {\n        require(account != address(0), \"zero address\");\n\n        _issuedSupply += amount;\n        _outstandingSupply += amount;\n        _balances[account] += amount;\n\n        emit Issued(account, amount);\n    }\n\n    //redeem, caller handles transfer of created value\n    function redeem(address account, uint256 amount) public onlyOwner {\n        require(account != address(0), \"zero address\");\n        require(_balances[account] >= amount, \"Insufficent balance\");\n\n        _balances[account] -= amount;\n        _outstandingSupply -= amount;\n\n        emit Redeemed(account, amount);\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint256) {\n        return _decimals;\n    }\n\n    function issuedSupply() public view returns (uint256) {\n        return _issuedSupply;\n    }\n\n    function outstandingSupply() public view returns (uint256) {\n        return _outstandingSupply;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}